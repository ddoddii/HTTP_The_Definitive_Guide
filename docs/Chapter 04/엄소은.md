## Chapter 4: 커넥션 관리

### 4.1 TCP 커넥션

- 모든 HTTP 통신은 TCP/IP 를 통해 이루어진다.
- `http://www.joes-hardware.com:80/power-tools.html` 을 접속한다고 하자. 브라우저가 `www.joes-hardware.com` 라는 호스트명을 추출하고, 이 호스트명에 해당하는 IP주소를 찾는다. 포트번호 80을 얻는다. 브라우저는 해당 IP 주소의 80번 포트로 TCP 커넥션을 생성한다. 브라우저가 서버로 GET 요청 메세지를 보낸다. 서버에게서 응답이 온 HTTP 응답 메세지를 읽는다. 그 후 브라우저는 서버와 커넥션을 종료한다.

#### 신뢰할 수 있는 전송 통로인 TCP

- TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

#### TCP 스트림은 세그먼트로 나뉘어 IP패킷을 통해 전송된다

- TCP 는 IP패킷을 통해 데이터를 전송한다.
- HTTP 의 프로토콜 스택 : Network Interface -> IP -> TCP -> HTTP
- HTTPS 의 프로토콜 스택 : Network Interface -> IP -> TCP -> TLS or SSL -> HTTP
- TCP는 세그멘트라는 단위로 데이터 스트림을 잘게 나누고, 세그멘트를 IP 패킷에 담아서 인터넷을 통해 데이터를 전달한다.

#### TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. TCP는 포트 번호를 통해 여러 개의 연결을 유지한다.
- TCP 커넥션은 4가지 값으로 식별한다 - <발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>

#### HTTP 트랜잭션 지연

- 실제 트랜잭션을 처리하는 시간은 TCP가 커넥션을 설정하고, 요청을 전송하고, 응답 메세지를 보내는 것에 비하면 상당히 짧다.
- 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
- HTTP 트랜잭션을 지연시키는 원인은 여러 가지가 있다.
  - 클라이언트가 URI 의 호스트에 방문한 적이 최근에 없으면, DNS에게 호스트 명을 IP 주소로 변환하는데 시간이 걸린다.
  - 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다.
  - 요청 메세지가 TCP 파이프를 통해 전달되고 서버에 의해 처리되는데 까지는 시간이 소요된다.
  - 웹서버가 HTTP 응답을 보내는 것도 시간이 소요된다.

#### 성능 관련 중요 요소

- TCP 관련 지연들은 다음 요소들이 있다.
  - TCP 커넥션의 핸드셰이크 과정
  - 인터넷의 혼잡을 제어하기 위한 TCP 의 slow-start
  - 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
  - TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
  - TIME_WAIT 지연과 포트 고갈

#### TCP 커넥션 핸드셰이크 지연

- TCP 커넥션이 핸드셰이크 하는 순서는 아래와 같다.
  1. 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 서버에 'SYN' 플래그를 가진 작은(40~60바이트) TCP 패킷을 전송한다.
  2. 서버가 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 'SYN' 과 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다.
  3. 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해 서버에게 다시 확인응답 신호를 보낸다.

#### 확인응답 지연

- 인터넷은 패킷 전송을 완벽하게 보장하지 않기 때문에, TCP 는 자체적인 확인 체계를 가진다.
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다. 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작인 확인응답 패킷을 송신자에게 반환한다. 만약 송신자가 특정 시간 안에 확인응답을 받지 못하면 패킷이 제대로 전달이 안된것으로 판단해 데이터를 재전송한다.
- 확인응답은 크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승(piggyback)시킨다. 따라서 네트워크를 좀 더 효율적으로 사용한다.
- 같은 방향으로 송출되는 데이터 패킷을 찾기 위해, TCP는 **확인응답 알고리즘**을 구현한다. 확인응답 지연은 송출할 확인응답을 특정 시간 동안(0.1~0.2초) 버퍼에 저장해두고, 확인응답을 편승시키기 위한 송출 데이터를 찾는다. 만약 시간 안에 송출 데이터를 찾지 못하면 별도의 패킷을 만들어 전송한다.
- 하지만 응답,요청 2가지 형식으로만 이루어지는 HTTP 동작 방식은, 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킨다. 따라서 확인응답 지연 알고리즘으로 인한 지연이 많이 발생한다.

#### TCP slow start

- TCP 전송 속도는 처음에는 속도를 느리게 제한했다가, 시간이 지나면서 자체적으로 '튜닝' 되어서 데이터가 성공적으로 전송됨에 따라 속도 제한을 높인다. 이렇게 조율하는 것을 TCP slow-start 라고 한다.
- '튜닝'된 커넥션은 더 빠르게 때문에, HTTP에는 이미 존재하는 커넥션을 재사용하는 기능이 있다.

#### Nagle 알고리즘과 TCP_NODELAY

- 어플리케이션은 아무리 작은 크기의 데이터라도 TCP 세그멘트로 전송하는데, TCP는 40byte 상당의 헤더와 플래그를 포함하기 때문에 작은 크기의 데이터를 많이 전송하면 네트워크 성능이 저하될 수 있다.
- 네이글 알고리즘에서는 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다. 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않는다. 다만, 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락한다. 다른 패킷들이 전송 중이면 버퍼에 저장된다. 전송되고 나서 확인응답을 기다리던 패킷이 확인응답을 받았거나, 버퍼에 패킷이 충분히 쌓였을 때 데이터가 전송된다.
- 하지만 네이글 알고리즘은 HTTP 성능에 여러 문제를 발생시킨다.
  - 첫번째로, 크기가 작은 HTTP 메세지는 패킷을 채우지 못하기 때문에 앞으로 추가적인 데이터를 기다리며 지연된다.
  - 두번째로, 확인응답 지연 알고리즘과 함께 쓰였을 시 형편없이 동작한다.
- HTTP는 성능 향상을 위해 네이글 알고리즘을 비활성화하는 `TCP_NODELAY` 파라미터를 설정하기도 한다.

#### TIME_WAIT의 누적과 포트 고갈

- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어 영역에 저장한다. 이것은 같은 주소와 포트번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것으로, 보통 세그먼트의 최대 생명주기의 두배 정도(약 2분) 시간 동안만 유지된다. 이것은 전의 커넥션과 같은 IP주소, 포트번호를 가진 커넥션이 2분 이내에 또 생성되는 것을 막는다.
- 이것은 **성능 측정 상황**에서 성능 저하를 발생시킨다. 한개의 클라이언트, 한개의 웹서버가 있고, TCP 커넥션을 맺기 위한 4개의 값(발신지 IP주소, 발신지 포트, 목적지 IP주소, 목적지 포트) 이 있을 때 발신지 포트만 변경하고 나머지 3개는 고정되어 있다고 하자. 사용할 수 있는 발신지 포트는 제한되어 있고(약 60,000개 라고 가정), 2MSL초(약 120초라고 가정) 동안 커넥션이 재사용될 수 없으므로 초 당 500개 (60,000/120) 로 커넥션이 제한된다.

### 4.3 HTTP 커넥션 관리

#### 흔히 잘못 이해하고 있는 Connection 헤더

- HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허락한다. HTTP 메세지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달된다.
- 어떤 경우에는 두 개의 인접한 HTTP 어플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있는데, HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 갖고 있다.

#### 순차적인 트랜잭션 처리에 의한 지연

- 화면 안에 이미지 3개가 있을 때, 이를 위해 4개의 HTTP 트랜잭션을 만들어야 한다. 각 트랜잭션이 새로운 커넥션을 필요로 하면 지연이 발생할 것이다.
- 따라서 HTTP 커넥션의 성능을 향상시킬 수 있는 기술에 대해 살펴보자.

### 4.4 병렬 커넥션

- HTTP 는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

#### 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹 페이지를 더 빠르게 내려받을 수 있을 것이다.

#### 병렬 커넥션이 항상 더 빠르지는 않다

- 여러 개의 객체를 병렬로 내려 받는 경우, 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어진다.
- 또한 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.
- 따라서 브라우저는 실제로 병렬 커넥션을 적은 수 (대부분 4개)만 허용한다.

#### 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 실제로 더 빠른 것은 아니지만, 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자 입장에서는 더 빠르게 느껴질 수 있다.

### 4.5 지속 커넥션

- 웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺는데, 왜냐하면 대부분의 리소스가 같은 웹 사이트에 있기 때문이다. 이것을 사이트 지역성(site locality) 라고 부른다.
- HTTP/1.1 은 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재활용할 수 있다. 이것을 지속 커넥션이라고 부른다. 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지한다.

#### 지속 커넥션 vs. 병렬 커넥션

- 병렬 커넥션은 아래의 단점들이 있다.

  - 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소모된다.
  - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
  - 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.

- 지속 커넥션은,
  - 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고,
  - 튜닝된 커넥션을 유지하며,
  - 커넥션 수를 줄여준다.
- 오늘날 많은 웹은 지속 + 병렬 커넥션 조합을 사용한다.
- 두가지 지속 커넥션 타입이 있는데, HTTP/1.0+ 에는 'keep-alive' 커넥션이 있고, HTTP/1.1에는 '지속' 커넥션이 있다.

#### HTTP/1.0+ 의 Keep-Alive 커넥션

- 지속 커넥션은 요청마다 커넥션을 맺고 끊는 데 필요한 작업이 없어서 시간이 단축된다.

#### Keep-Alive 동작

- keep-alive 는 사용하지 않기로 결정되어 HTTP/1.1 에서 빠졌지만, 여전히 브라우저-서버 간에 keep-alive 핸드셰이크가 널리 사용되고 있기 떄문에 HTTP 어플리케이션은 이것을 처리해야 한다.
- HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 요청에 `Conncetion:Keep-Alive` 헤더를 포함시킨다.
- 이 요청을 받은 서버는 다음 요청도 이 커넥션으로 받고자 하면, 응답 메세지에 같은 헤더를 포함시켜 응답한다.
- 응답에 `Conncetion:Keep-Alive` 헤더가 포함되어 있지 않으면, 클라이언트는 서버가 keep-alive 를 지원하지 않으며 응답 메세지가 전송된 후 커넥션을 끊을 것이라 추정한다.

#### Keep-Alive 옵션

- Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다. 따라서 이 요청을 받았다고 해서 무조건 따를 필요는 없다.
- 아래는 헤더에 있는 Keep-Alive 의 파리미터이다. 하지만 아래처럼 동작한다는 보장은 없다.
  - `timeout` : 커넥션이 얼마나 유지될 것인지 의미한다.
  - `max` : 커넥션이 몇개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지를 의미한다.

#### Keep-Alive 커넥션 제한과 규칙

- Keep-Alive 는 HTTP/1.0 에서 디폴트가 아니다. 클라이언트는 `Conncetion:Keep-Alive` 요청헤더를 보내야 한다.
- 커넥션을 계속 유지하려면 모든 메세지에 `Conncetion:Keep-Alive` 헤더를 포함시켜야 한다.
- 클라이언트는 `Conncetion:Keep-Alive` 응답 헤더가 없는 것을 보고 서버가 응답후에 커넥션을 끊을 것임을 알 수 있다.
- 프락시와 게이트웨이는 메세지를 전달하거나 캐시에 넣기 전에 Conncetion 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다.
- keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안된다.

#### Keep-Alive 와 멍청한(dumb) 프락시

##### Connection 헤더의 무조건 전달

- 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다.
- 웹 클라이언트가 Connection 헤더를 무조건 전달하는 멍청한 프락시를 거쳐서 서버에 메시지를 전송한다고 하자.
  1. 클라이언트는 프락시에 `Conncetion:Keep-Alive` 헤더와 함께 메시지를 보내고, 커넥션을 유지하기를 요청한다.
  2. 멍청한 프락시는 요청받은 HTTP의 커넥션 헤더를 이해하지 못하고, 다음 서버에 그대로 메세지를 전달한다. 하지만 커넥션 헤더를 **hop-by-hop 헤더**이다. 즉, 오직 한 개의 전송 링크에만 적용되며 다음 서버로 전달되어서는 안된다 !
  3. 전달된 HTTP 요청이 서버에 도착한다. 웹 서버가 프락시로부터 `Conncetion:Keep-Alive` 헤더를 받으면, 웹 서버는 프락시가 커넥션을 유지하자고 요청하는 것으로 잘못 판단한다 🤯. 서버는 동의하고, `Conncetion:Keep-Alive` 헤더를 포함하여 응답한다.
  4. 멍청한 프락시는 서버로부터 받은 `Conncetion:Keep-Alive` 헤더를 포함하고 있는 응답 메세지를 클라이언트에게 전달한다. 클라이언트는 서버도 Keep-Alive 요청에 동의했다고 추정한다 🤯.
  5. 프락시는 Keep-Alive 를 전혀 모르지만, 받았던 모든 데이터를 클라이언트에게 전달하고 나서 서버가 커넥션을 끊기를 기다린다. 하지만 서버는 프락시와 지속 커넥션을 하기로 약속했기 때문에 커넥션을 끊지 않는다. 따라서 프락시는 커넥션이 끊어질 때까지 계속 기다린다 😞.
  6. 클라이언트가 응답을 받으면, 다시 요청을 보내는데, 프락시는 같은 커넥션 상에서 다른 요청이 오는 경우는 예상하지 못하기 때문에 그 요청은 무시한다.
  7. 이러한 잘못된 통신 때문에 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다린다.

##### 프락시와 홉별 헤더

- 이런 잘못된 통신을 피하려면, 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안된다.
- 또한 Connection 헤더의 값으로 명시되지 않는 Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 와 같은 홉별 헤더도 전달하면 안된다.

#### Proxy-Connection 살펴보기

- 프락시가 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 Proxy-Connection 헤더를 사용하는 방법이 나왔다.
- 홉별 헤더들은 한 개의 특정 커넥션에서 쓰이고, 그 이후에는 전달하면 안된다.
- 넷스케이프는 멍청한 프락시 문제를 해결하기 위해 Connection 헤더 대신 Proxy-Connection 헤더를 프락시에 전달한다. 프락시가 Proxy-Connection 헤더를 무조건 전달하더라도 웹 서버는 이것을 무시하므로 문제가 되지 않는다. 영리한 프락시는 Proxy-Connection 헤더를 Connection 헤더로 바꿈으로써 원하는 효과를 얻게 된다.

<img width="781" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/928d3d20-076d-4d57-b4b4-90b6febf036a">

- 그러나 멍청한 프락시가 영리한 프락시 양 옆에 있으면 또 헤더를 잘못 전달하는 문제가 여전히 발생한다.

#### HTTP/1.1 의 지속 커넥션

- HTTP/1.1 에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 **지속 커넥션**을 지원한다.
- 이것은 기본적으로 활성화되어 있다. 만약 트랜잭션이 끝난 다음 다음 커넥션을 끊으려면 `Connection: close` 헤더를 명시해야 한다.

#### 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 `Connection: close` 헤더를 포함해서 보냈으면 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 커넥션에 있는 모든 메세지가 자신의 길이 정보를 정확히 가지고 있을 때만 커넥션을 지속시킬 수 있다.
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다.
- HTTP/1.1 프락시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 모르면 지속 커넥션을 맺으면 안된다.
- HTTP/1.1 기기는 Connection 헤더의 값과는 상관없이 언제든지 커넥션을 끊을 수 있다.
- HTTP/1.1 어플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 한다.

### 4.6 파이프라인 커넥션

- HTTP/1.1은 지속 커넥션을 통해 요청을 **파이프라이닝** 할 수 있다.
- 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓인다. 첫번째 요청이 지구 반대편 서버로 전달되면, 거기에 이어 두번째, 세번째 요청이 전달될 수 있다. 이는 네트워크 상의 왕복으로 인한 시간을 줄여 성능을 높여준다.

![파이프라인커넥션](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/3704bcc6-6bcf-4da1-98ac-e5947fa9c3c4)

### 4.7 커넥션 끊기에 대한 미스터리

#### '마음대로' 커넥션 끊기

- 어떠한 HTTP 클라이언트, 서버, 혹은 프락시는 언제든지 TCP 전송 커넥션을 끊을 수 있다.

#### Content-Length 와 Truncation

- 각 HTTP 응답은 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.

#### 커넥션 끊기의 허용, 재시도, 멱등성

- 클라이언트가 트랜잭션 수행 중에 전송 커넥션이 끊기게 되면, 클라이언트는 재시도 하더라도 문제가 없으면 커넥션을 다시 맺고 재전송을 시도해야 하는데, 이것은 파이프라인 커넥션에서 어렵다. 클라이언트는 여러 요청을 큐에 쌓아 놓을 수 있지만, 서버는 아직 처리되지 않고 스케쥴이 조정되어야 하는 요청들을 남겨둔 채로 커넥션을 끊어버릴 수도 있다.
- 어떤 요청 데이터가 전송되었지만, 응답이 오기 전 커넥션이 끊기면 클라이언트는 서버가 어느 정도 요청을 처리했는지 모른다. 이것은 멱등(idempotent)하지 않는 트랜잭션(POST) 를 파이프라인을 통해 요청했을 때 문제가 생긴다.

#### 우아한 커넥션 끊기

##### 전체 끊기와 절반 끊기

- 어플리케이션은 TCP 입력 채널과 출력 채널 중 한개만 끊거나 둘 다 끊을 수 있다.
- `close()` 를 호출하면 TCP 입력 채널과 출력 채널 커넥션을 모두 끊는다.
- `shutdown()` 은 TCP 입력 채널과 출력 채널 중 하나만 개별적으로 끊는다.

##### TCP끊기와 리셋 에러

- 어플리케이션이 예상치 못한 쓰기 에러를 발생하는 것을 예방하기 위해 절반 끊기를 사용해야 한다. 보통 출력 채널을 끊는 것이 안전하다.
- 클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험하다. 만약 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송할 경우 서버의 운영체제는 TCP 'connection reset by peer' 를 클라이언트에게 보낸다. 그러면 버퍼에 저장된 읽히지 않은 모든 데이터를 샂게한다.

##### 우아하게 커넥션 끊기

- 일반적으로 어플리케이션의 우아한 커넥션 끊기는 자신의 출력 채널을 먼저 끊고, 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다.
