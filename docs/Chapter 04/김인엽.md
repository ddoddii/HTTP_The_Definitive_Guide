# 4.1 TCP 커넥션
### 브라우저에서 url 입력했을 때 동작 원리 
1. 브라우저가 `http://www.naver.com:80/main` 에서 호스명을 추출한다. 
2. 브라우저가 이 호스명에 맞는 IP 주소를 찾는다. 
3. 브라우저가 포트 번호(80)를 얻는다.
4. 브라우저가 IP 주소와 포트번호 80을 결합하여 TCP 커넥션을 생성한다. 
5. 브라우저가 서버로 GET 요청 메시지 보낸다. 
6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다. 
7. 브라우저가 커넥션을 끊는다. 

## 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

## 4.1.2. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다. 
HTTPS는 HTTP에 비해 보안 계층을 추가된 프로토콜 스택이라는 점에서 차이점이 있다. 
TCP는 세그먼트 단위로 데이터를 전송한다. 이 과정에서 IP 패킷이라는 봉투에 세그먼트를 담아서 전송한다. 

## 4.1.3 TCP 커넥션 유지하기 
- 커넥션: `발신자 IP 주소, 발신자 포트, 수신자 IP 주소, 수신자 포트` 로 4가지 값으로 유일한 커넥션을 생성한다. 
- 위 4가지 속성 값을 모두 동일한 케넥션은 있을 수 없다. 

# 4.2 TCP의 성능에 대한 고려 
HTTP. 트랜젝션 성능은 필연적으로 TCP 성능에 영향을 받을 수 밖에 없다. 
## 4.2.1 HTTP 트랜젝션 지연 
- 실제 트랜젝션 처리시간은 상당히 짧다. 
- TCP 커넥션 설정, 요청 전송, 응답 메시지 전송에서 많은 시간이 걸린다. 
- 즉, HTTP 지연은 TCP 네트워크 지연 때문이다. 

### 트렌젝션 지연 원인 
1. IP 주소를 알아내기 위한 DNS 이름 분석 인프라에서 시간 소요
2. 커넥션 설정 시간: 커넥션 허용 응답을 회신하는 시간 
3. TCP 파이프를 통한 요청 메시지 전달 및 서버 처리 시간 
4. 서버에서 오는 응답 시간 

## 4.2.2 성능 관련 중요 요소
- TCP 커넥션의 핸드셰이크 설정 
- 인터넷 혼잡 제어를 위한 TCP 느린 시작
- 한 번에 전송하기 위한 네이글 알고리즘
- 확인 응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

## 4.2.3 TCP 커넥션 핸드셰이크 지연
### 핸드세이크 과정
1. 클라이언트가 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 서버에게 전송. SYN 플래그 
2. 서버가 그 커넥션 받으면 커넥션 요청이 받아들였다는 'SYN'와 'ACK' 플래그 포함하여 TCP 패킷 전송
3. 클라이언트가 잘 맺어졌다는 의미로 서버에게 확인 응답 신호 전송한다.
	(오늘날에 클라이언트 확인응답 패킷과 데이터를 함께 보낸다.)

- 핸드셰이크 과정에서도 확인할 수 있듯 작은 데이터를 보내기 위해 커넥션 과정에서 오랜 시간 소모. 

## 4.2.4 확인응답 지연
- 인터넷 환경 신뢰하기 어려움 
- TCP 에서 성공적인 데이터 전송 보장하기 위해서 확인 체계 갖춤
- 데이터 패킷에 이 확인응답을 '편승'(함께 보내)하여 네트워크를 효율적으로 사용하고자 함.
- 데이터 패킷에 함께 보내기 위해서 '확인응답 지연' 알고리즘을 개발 
- 하지만 이 '확인응답 지연' 알고리즘 때문에 전반적인 통신이 지연되는 결과를 낳을 수 있다. 

## 4.2.5 TCP 느린 시작(Slow Start)
- 커넥션 초반 최대 속도를 제한하는 방법
- 성공적인 커넥션이 지속되면 '튜닝'하여 최대 속도를 높여가는 방식이다. 
- 커넥션의 갑작스러운 부하와 혼잡을 막기 위한 방법

## 4.2.6 네이글 알고리즘과 TCP_NODELAY
- 작은 크기 데이터를 여러 패킷으로 전송하면 효율성 떨어진다
- 하나 TCP 데이터 패킷으로 뭉쳐서 보내는 방식.
- 최대 크기 세그먼트가 되지 않으면 전송하지 않는다. 
- 문제1: 추가적인 데이터 기다리며 지연
- 문제2: '확인응답 지연 알고리즘' 때문에 더욱 느려짐 
- TCP_NODELAY 파라미터 설정하면 네이글 알고리즘 사용하지 않을 수 있음

## 4.2.7 TIME_WAIT의 누적과 포트 고갈
- 새로운 커넥션 생기지 않기 위해 메모리 제어 영역에 IP 주소와 포트 번호를 저장한다. 
- 이런 제약 때문에 초당 커넥션 수가 제한된다. 

# 4.3 HTTP 커넥션 관리 

## 4.3.1 흔히 잘못 이해하는 Connection 헤더 
- HTTP 헤더 필드 명에는 이 커넥션에만 해당하는 헤더를 나열한다. 
- 임시 토큰 값는 커넥션에서 비표준 옵션이다. 
- close 값이 커넥션 작업이 끝나면 종료를 뜻한다. 

## 4.3.2 순차적인 트랜잭션 처리에 의한 지연 
- 순차적인 트랜잭션 처리로 이용자는 심리적으로 더 느리게 지연된다고 느낀다.
- 실제 병렬처리가 순차 트랜젝션보다 느리더라도 이용자는 동시에 로드되길 원한다. 

# 4.4 병렬 커넥션 
## 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다. 
- 지연 시간 줄일 수 있다. 
- 객체 처리에 남은 대역폭 사용할 수 있다. 
- 별도 커넥션으로 동시 처리된다. 
## 4.4.2 병렬 커넥션이 항상 더 빠르지 않다. 
- 항상 병렬 처리가 더 빠르지 않다
- 네트워크 대역폭이 좁으면 병렬 처리에 장점이 없다. 
- 다수 커넥션은 메모리 만힝 소모하여 자체 성능이 좋지 못할 수 있다. 
- 병렬 커넥션은 더 빠르게 느낄 수 있다. 

# 4.5 지속 커넥션
- 서버에 지속적인 요청을 보내는 속성을 사이트 지역성이라고 한다. 
- 하나 트랜젝션 처리가 완료되더라도 계속 연결 상태를 유지하는 것을 지속 커넥션이라고 한다. 
- 이미 있는 커넥션을 재사용하여 준비작업 시간을 아낄 수 있다. 

## 4.5.1 지속 커넥션 vs 병렬 커넥션
### 병렬 커넥션 단점
- 새로운 커넥션 맺고 끊어서 시간과 대역폭 소요
- TCP 느린 시작 시간 때문에 성능 떨어짐
- 병렬 커넥션 수 제한

### 지속 커넥션 장점
- 튜닝된 커넥션 이용가능
- 커넥션 수 줄여줌 
- 불필요한 준비 시간 없음

병렬 커넥션과 지속 커넥션 둘 다 사용한다. 

## 4.5.3 Keep-Alive 동작원리 (HTTP/1.0)
- 요청에 Connection: Keep-Alive 헤더 포함 
- 무조건 요청을 따를 필요 없음 
- 만약 서버에서 응답 헤더로 내려오지 않으면 클라이언트는 커넥션 끊을 것

## 4.5.6 Keep-Alive와 멍청한 프락시 
- 멍청한 프락시가 클라이언트와 서버 사이에 존재할 때, Keep-Alive 헤더 전달로 인한 문제가 발생한다. 
- Keep-Alive를 이해할 수 없는 프락시가 클라이언트 요청을 서버에 전달하여 클라이언트와 서버 모두 Keep-Alive를 기대하게 한다 

## 4.5.7  Proxy-Connection 살펴보기
- 위와 같은 문제를 파훼하기 위해서 Proxy에게 별도 설정할 수 있는 헤더가 Proxy-Connection이다 

## 4.5.8 HTTP/1.1의 지속 커넥션 
- 1.0과 달리 1.1.에서 지속 커넥션이 기본 설정이다. 
- 그러나 클라이언트와 서버 모두 지속 커넥션을 언제든지 끊을 수 있다. 

# 4.6 파이프라인 커넥션 
- 지속 커넥션을 넘어서 파이프라인 지속 커넥션은 응답이 오기 전에 또 다른 요청을 보내서 효율성을 높이는 방식이다. 

# 4.7 커넥션 끊기에 대한 미스터리 
## 4.7.1 '마음대로' 커넥션 끊기 
- 파이프라인에서도 언제든지 커넥션이 끊어질 수 있다. 
- 유휴 커넥션이라고 하더라도 끊는 순간 클라이언트가 요청한 순간일 수 있다. 

## 4.7.4 우아한 커넥션 끊기 
- 우아하게 커넥션 끊기 위해서 입력 혹은 출력 채널 하나를 닫는 '절반 끊기'를 사용하면 좋다.
- 대게 더 이상 보내지 않을 것을 암시할 수 있는 출력 채너를 먼저 닫는 것이 안전하다. 
- 하지만 상대측에서 출력 채널을 닫은 것을 확인할 방법이 있는지 검사할 방법이 없다. 
- 이런한 문제로 입력 채널을 주기적으로 확인하고, 일정 시간이 지나면 강제로 커넥션을 끊어내는 방식을 쓸 수 밖에 없다. 
